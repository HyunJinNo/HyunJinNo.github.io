---
title: KMP 알고리즘
description: KMP (Knuth-Morris-Pratt) 알고리즘에 대해 정리한 페이지입니다.
date: 2024-04-08 00:00:00 +/-TTTT
categories: [Algorithms]
tags: [algorithm]
math: true
toc: true
pin: false
image:
  path: /assets/img/algorithms/computer.avif
comments: true
---

<blockquote class="prompt-info"><p><strong><u>Tags</u></strong> <br />
Algorithm</p></blockquote>

## 개요

`KMP(Knuth-Morris-Pratt)` 알고리즘에 대해 정리한 페이지입니다.

## KMP (Knuth-Morris-Pratt) 알고리즘

### 개념

`KMP(Knuth-Morris-Pratt)` 알고리즘은 <b>문자열 검색 알고리즘</b>으로, <b>문자열 검색 시 불일치가 일어났을 때 지금까지 일치한 글자 수를 이용하여 다음으로 시도해야 할 시작 위치를 빠르게 찾아낼 수 있도록 고안된 알고리즘</b>입니다.

긴 문자열 내 짧은 문자열(=패턴)이 포함되는지 확인할 때, 일반적인 문자열 검색 알고리즘은 불일치가 발생하면 패턴을 처음부터 다시 비교하지만, <b>KMP 알고리즘은 이미 비교한 정보를 이용해 패턴을 부분적으로만 이동</b>하여 중복 비교를 피하고 시간을 절약합니다. 즉, <b>패턴 매칭 실패 시 이미 비교한 정보를 활용해 불필요한 비교를 건너뛰고 다음 비교 위치로 이동하는 것</b>이 KMP 알고리즘의 핵심 아이디어입니다.

### 특징

KMP 알고리즘의 특징은 다음과 같습니다.

- `부분 일치 테이블(=LPS 배열, Longest Prefix which is also Suffix)`

  KMP 알고리즘은 현재 위치까지의 접두사(Prefix)와 접미사(Suffix)가 일치하는 최대 길이를 저장하는 LPS 배열을 생성합니다. 긴 문자열과 짧은 문자열(=패턴)을 비교하여 불일치가 일어나면 LPS 배열을 참고해 다음 비교 위치로 빠르게 이동하게 됩니다.

- `시간 복잡도(Time Complexity)`

  긴 문자열의 길이가 `N`이고 패턴의 길이가 `M`일 때, KMP 알고리즘을 사용하면 LPS 배열을 생성하는데 `O(M)`의 시간이 걸리고, 문자열을 검색하는데 `O(N)`의 시간이 걸리므로 총 시간 복잡도는 `O(N + M)`입니다. 이는 브루트포스 방식으로 문자열 검색을 수행했을 때 걸리는 `O(N * M)`의 시간 복잡도보다 효율적입니다.

- <b>접미사 배열(Suffix Array)</b>
  - <b>접미사 배열(Suffix Array)</b>란 어떤 문자열 S의 모든 접미사를 사전순으로 정렬해둔 것을 말한다.
  - 모든 접미사들을 문자열 배열에 저장해두면 문자열 길이의 제곱에 비례하는 메모리가 필요하기 때문에, 일반적으로 접미사 배열은 <b>각 접미사의 시작 위치를 담은 정수 배열</b>로 구현된다.
  - 접미사 배열을 이용하여 문자열 검색을 할 수 있다. 접미사 배열을 이용한 문자열 검색은 긴 문자열 H가 짧은 문자열 N을 포함한다면 <b>항상 N은 H의 어떤 접미사의 접두사</b>라는 점을 이용한다. 이 속성을 이용하면 H의 접미사 배열을 <b>이진 탐색</b>해서 각 문자열이 출현하는 위치를 찾을 수 있다.
  - 접미사 배열의 길이는 항상 <code>|H|</code>이고 이진 탐색의 내부는 <code>O(lg|H|)</code>번 수행된다. 각 문자열 비교에 <code>O(|N|)</code> 시간이 걸리므로 이진 탐색의 수행 시간은 <code>O(|N|lg|H|)</code>이 된다.

### 구현

KMP 알고리즘은 크게 다음 두 단계로 이루어집니다.

#### 부분 일치 테이블(=LPS 배열, Longest Prefix which is also Suffix) 만들기

```javascript
/**
 * KMP 알고리즘을 이용해 부분 일치 테이블을 생성하는 함수
 * @param {string} pattern
 * @returns {number[]} 부분 일치 테이블
 */
const buildLPS = (pattern) => {
  const lps = Array(pattern.length).fill(0);

  // KMP로 자기 자신을 찾습니다.
  // begin이 0이면 자기 자신을 찾으므로 제외합니다.
  let begin = 1;
  let matched = 0;

  // 비교할 문자가 pattern의 끝에 도달할 때까지 찾으면서 부분 일치를 모두 기록합니다.
  while (begin + matched < pattern.length) {
    if (pattern[begin + matched] === pattern[matched]) {
      matched++;
      lps[begin + matched - 1] = matched;
    } else {
      if (matched === 0) {
        begin++;
      } else {
        begin += matched - lps[matched - 1];
        matched = lps[matched - 1];
      }
    }
  }

  return lps;
};

const pattern = "ABABCABAB";
console.log(buildLPS(pattern)); // [0, 0, 1, 2, 0, 1, 2, 3, 4]
```

#### 문자열 검색

```javascript
/**
 * 긴 문자열 text의 부분 문자열로 짧은 문자열 pattern이 출현하는 시작 위치들을 모두 반환하는 함수
 * @param {string} text 긴 문자열
 * @param {string} pattern 짧은 문자열
 * @returns {number[]} 긴 문자열 text의 부분 문자열로 짧은 문자열 pattern이 출현하는 시작 위치들을 담은 배열
 */
const kmpSearch = (text, pattern) => {
  const result = [];
  const lps = buildLPS(pattern);

  let begin = 0;
  let matched = 0;

  while (begin <= text.length - pattern.length) {
    if (
      matched < pattern.length &&
      text[begin + matched] === pattern[matched]
    ) {
      matched++;

      // 결과적으로 글자가 모두 일치했다면 답에 추가합니다.
      if (matched === pattern.length) {
        result.push(begin);
      }
    } else {
      // 예외: matched가 0인 경우에는 다음 칸에서부터 계속합니다.
      if (matched === 0) {
        begin++;
      } else {
        begin += matched - lps[matched - 1];

        // begin을 옮겼다고 처음부터 다시 비교할 필요가 없습니다.
        // 옮긴 후에도 lps[matched - 1]만큼은 항상 일치합니다.
        matched = lps[matched - 1];
      }
    }
  }

  return result;
};
```

#### 최종 구현

최종 구현 결과는 다음과 같습니다.

```javascript
/**
 * KMP 알고리즘을 이용해 부분 일치 테이블을 생성하는 함수
 * @param {string} pattern
 * @returns {number[]} 부분 일치 테이블
 */
const buildLPS = (pattern) => {
  const lps = Array(pattern.length).fill(0);

  // KMP로 자기 자신을 찾습니다.
  // begin이 0이면 자기 자신을 찾으므로 제외합니다.
  let begin = 1;
  let matched = 0;

  // 비교할 문자가 pattern의 끝에 도달할 때까지 찾으면서 부분 일치를 모두 기록합니다.
  while (begin + matched < pattern.length) {
    if (pattern[begin + matched] === pattern[matched]) {
      matched++;
      lps[begin + matched - 1] = matched;
    } else {
      if (matched === 0) {
        begin++;
      } else {
        begin += matched - lps[matched - 1];
        matched = lps[matched - 1];
      }
    }
  }

  return lps;
};

/**
 * 긴 문자열 text의 부분 문자열로 짧은 문자열 pattern이 출현하는 시작 위치들을 모두 반환하는 함수
 * @param {string} text 긴 문자열
 * @param {string} pattern 짧은 문자열
 * @returns {number[]} 긴 문자열 text의 부분 문자열로 짧은 문자열 pattern이 출현하는 시작 위치들을 담은 배열
 */
const kmpSearch = (text, pattern) => {
  const result = [];
  const lps = buildLPS(pattern);

  let begin = 0;
  let matched = 0;

  while (begin <= text.length - pattern.length) {
    if (
      matched < pattern.length &&
      text[begin + matched] === pattern[matched]
    ) {
      matched++;

      // 결과적으로 글자가 모두 일치했다면 답에 추가합니다.
      if (matched === pattern.length) {
        result.push(begin);
      }
    } else {
      // 예외: matched가 0인 경우에는 다음 칸에서부터 계속합니다.
      if (matched === 0) {
        begin++;
      } else {
        begin += matched - lps[matched - 1];

        // begin을 옮겼다고 처음부터 다시 비교할 필요가 없습니다.
        // 옮긴 후에도 lps[matched - 1]만큼은 항상 일치합니다.
        matched = lps[matched - 1];
      }
    }
  }

  return result;
};

const text = "ABABCABABCABABCABAB";
const pattern = "ABABCABAB";
console.log(buildLPS(pattern)); // [0, 0, 1, 2, 0, 1, 2, 3, 4]
console.log(kmpSearch(text, pattern)); // [0, 5, 10]
```

## Example

- <a href="" target="_blank">TODO</a>

## 참고 자료

- <a href="https://namu.wiki/w/문자열%20알고리즘" target="_blank">문자열 알고리즘 - 나무위키</a>

????????????????????????????????????????????????????????????

## Introduction

- **Definition**

  - <b>문자열(String)</b>은 현대의 컴퓨터에서 다루는 자료 중 하나이다.
  - 문자열은 정보 검색(Information Retrieval)이나 생물 정보학(Bioinformatics) 분야에서 특히 유용하게 사용된다.
  - **주요 용어**
    - **부분 문자열(Substring)**: 문자열 S의 i번 글자부터 j번 글자까지로 구성된 문자열을 S의 부분 문자열(Substring)이라고 부른다.
    - **접두사(Prefix)**: 문자열 S의 0번 글자부터 a번 글자까지로 구성된 부분 문자열을 S의 접두사(Suffix)라고 부른다.
    - **접미사(Suffix)**: 문자열 S의 b번 글자부터 끝까지로 구성된 부분 문자열을 S의 접미사(Suffix)라고 부른다.
  - **문자열 검색**: 주어진 긴 문자열 H가 짧은 문자열 N을 부분 문자열로 포함하는지 확인하고, 포함한다면 N과 일치하는 부분 문자열의 시작 위치를 찾는 문제를 **문자열 검색 문제**라고 한다.
