---
title: LIS 알고리즘
description: LIS (Longest Increasing Subsequence, 최장 증가 부분 수열) 알고리즘에 대해 정리한 페이지입니다.
date: 2025-10-01 10:16:00 +/-TTTT
categories: [Algorithms]
tags: [algorithm]
math: true
toc: true
pin: false
image:
  path: /assets/img/algorithms/computer.avif
comments: true
---

<blockquote class="prompt-info"><p><strong><u>Tags</u></strong> <br />
Algorithm</p></blockquote>

## 개요

`LIS(Longest Increasing Subsequence, 최장 증가 부분 수열)` 알고리즘에 대해 정리한 페이지입니다.

## LIS (Longest Increasing Subsequence, 최장 증가 부분 수열)

### 개념

`LIS(Longest Increasing Subsequence, 최장 증가 부분 수열)` 알고리즘은 주어진 수열에서 오름차순으로 정렬된 가장 긴 부분 수열을 찾는 알고리즘입니다.

```text
수열: [10, 20, 10, 30, 20, 50]

-----------------------------

LIS: [10, 20, 30, 50]
길이: 4
```

### 구현

최장 증가 부분 수열을 찾는 알고리즘은 다음 두 가지 방법이 존재합니다.

#### DP 방법: O(N²)

다음과 같이 DP 방법으로 LIS를 구할 수 있습니다. `arr[i]`를 마지막으로 하는 LIS의 길이를 구해서 전체에서 최댓값을 찾는 방식으로 LIS의 길이를 구할 수 있습니다. 시간 복잡도는 `O(N²)`입니다.

```javascript
const arr = [10, 9, 2, 5, 3, 7, 101, 18];
const N = arr.length; // 8
const dp = Array(N).fill(1); // dp[i]: arr[i]를 마지막으로 하는 LIS의 길이

for (let i = 1; i < N; i++) {
  for (let j = 0; j < i; j++) {
    if (arr[j] < arr[i]) {
      dp[i] = Math.max(dp[i], dp[j] + 1);
    }
  }
}

console.log(dp); // [1, 1, 1, 2, 2, 3, 4, 4]
console.log(Math.max(...dp)); // 최장 증가 부분 수열의 길이: 4
```

만약 길이뿐만 아니라 실제 수열까지 필요한 경우 추가로 다음과 같이 구현할 수 있습니다. 원본 수열의 가장 마지막 인덱스부터 시작해서 0번 인덱스까지 역순으로 탐색하여 LIS를 얻을 수 있습니다.

| i   | 0   | 1   | 2        | 3   | 4        | 5        | 6   | 7         |
| --- | --- | --- | -------- | --- | -------- | -------- | --- | --------- |
| arr | 10  | 9   | <b>2</b> | 5   | <b>3</b> | <b>7</b> | 101 | <b>18</b> |
| dp  | 1   | 1   | <b>1</b> | 2   | <b>2</b> | <b>3</b> | 4   | <b>4</b>  |
|     |     |     |          |     |          |          |     |           |
| LIS |     |     | 2        |     | 3        | 7        |     | 18        |

```javascript
/* ... */
/* 위의 코드와 동일 */

let result = [];
let count = Math.max(...dp); // 4
let index = N - 1; // 7

while (count > 0) {
  if (dp[index] === count) {
    result.push(arr[index]);
    count--;
  }

  index--;
}

console.log(result.reverse()); // [2, 3, 7, 18]
```

#### 이분 탐색 방법: O(N log N)

아래와 같이 이분 탐색 방법으로 LIS를 구할 수 있습니다. 위의 DP 방법의 시간 복잡도는 `O(N²)`이지만, 이분 탐색 방법의 시간 복잡도는 `O(N log N)`이므로, LIS를 구할 때는 이분 탐색 방법을 사용하는 것이 좋습니다.

이분 탐색 방법의 아이디어는 <b>길이가 같은 증가 부분 수열들 중에서 마지막 숫자가 가장 최소인 것을 남기는 것</b>입니다. 배열에서 순서를 유지하면서 점점 커지는 숫자들을 최대한으로 길게 만들기 위해선 ...

```javascript
const arr = [10, 9, 2, 5, 3, 7, 101, 18];
const N = arr.length; // 6
const lis = [arr[0]]; // 길이가 index + 1 인 증가 부분 수열들 중에서 가장 마지막 숫자가 최소인 것

for (let i = 1; i < N; i++) {
  if (arr[i] <= lis[0]) {
    lis[0] = arr[i];
  } else if (arr[i] > lis[lis.length - 1]) {
    lis.push(arr[i]);
  } else {
    let left = 0;
    let right = lis.length - 1;

    while (left + 1 < right) {
      let mid = Math.floor((left + right) / 2);

      if (arr[i] <= lis[mid]) {
        right = mid;
      } else {
        left = mid;
      }
    }

    lis[right] = arr[i];
  }
}

// lis: [10, 20, 30, 50]
console.log(lis.length); // 최장 증가 부분 수열의 길이
```

만약 길이뿐만 아니라 실제 수열까지 필요한 경우 다음과 같이 구현할 수 있습니다.

```javascript
const arr = [10, 20, 10, 30, 20, 50];
const N = arr.length; // 6
const lis = [arr[0]];
const length = Array(N).fill(0);
length[0] = 1;

for (let i = 1; i < N; i++) {
  if (arr[i] <= lis[0]) {
    lis[0] = arr[i];
    length[i] = 1;
  } else if (arr[i] > lis[lis.length - 1]) {
    lis.push(arr[i]);
    length[i] = lis.length;
  } else {
    let left = 0;
    let right = lis.length - 1;

    while (left + 1 < right) {
      let mid = Math.floor((left + right) / 2);

      if (arr[i] <= lis[mid]) {
        right = mid;
      } else {
        left = mid;
      }
    }

    lis[right] = arr[i];
    length[i] = right + 1;
  }
}

console.log(lis.length); // 최장 증가 부분 수열의 길이

let result = [];
let count = lis.length; // 4
let index = N - 1; // 5

while (count > 0) {
  if (
    length[index] === count &&
    (result.length === 0 || result[result.length - 1] > arr[index])
  ) {
    result.push(arr[index]);
    count--;
  }

  index--;
}

console.log(result.reverse()); // [10, 20, 30, 50]
```

## Example

<a href="https://www.acmicpc.net/problem/2631" target="_blank">2631번: 줄세우기</a>

```javascript
const path = process.platform === "linux" ? "/dev/stdin" : "input.txt";
const input = require("fs").readFileSync(path).toString().split("\n");
const N = Number(input[0]); // 아이들의 수, 2 <= N <= 200
const arr = [];

for (let i = 1; i <= N; i++) {
  arr.push(Number(input[i]));
}

const lis = [arr[0]];

for (let i = 1; i < N; i++) {
  if (arr[i] <= lis[0]) {
    lis[0] = arr[i];
  } else if (arr[i] > lis[lis.length - 1]) {
    lis.push(arr[i]);
  } else {
    let left = 0;
    let right = lis.length - 1;

    while (left + 1 < right) {
      let mid = Math.floor((left + right) / 2);

      if (arr[i] <= lis[mid]) {
        right = mid;
      } else {
        left = mid;
      }
    }

    lis[right] = arr[i];
  }
}

console.log(N - lis.length);
```

## 참고 자료

- <a href="https://namu.wiki/w/최장%20증가%20부분%20수열" target="_blank">최장 증가 부분 수열 - 나무위키</a>
