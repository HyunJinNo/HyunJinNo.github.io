---
title: LIS 알고리즘
description: LIS (Longest Increasing Subsequence, 최장 증가 부분 수열) 알고리즘에 대해 정리한 페이지입니다.
date: 2025-10-01 10:16:00 +/-TTTT
categories: [Algorithms]
tags: [algorithm]
math: true
toc: true
pin: false
image:
  path: /assets/img/algorithms/computer.avif
comments: true
---

<blockquote class="prompt-info"><p><strong><u>Tags</u></strong> <br />
Algorithm</p></blockquote>

## 개요

`LIS(Longest Increasing Subsequence, 최장 증가 부분 수열)` 알고리즘에 대해 정리한 페이지입니다.

## LIS (Longest Increasing Subsequence, 최장 증가 부분 수열)

### 개념

`LIS(Longest Increasing Subsequence, 최장 증가 부분 수열)` 알고리즘은 주어진 수열에서 오름차순으로 정렬된 가장 긴 부분 수열을 찾는 알고리즘입니다.

### 특징

### 활용

### 구현

#### DP 방법

#### 이분 탐색 방법

## Example

<a href="https://www.acmicpc.net/problem/2631" target="_blank">2631번: 줄세우기</a>

```javascript
const path = process.platform === "linux" ? "/dev/stdin" : "input.txt";
const input = require("fs").readFileSync(path).toString().split("\n");
const N = Number(input[0]); // 아이들의 수, 2 <= N <= 200
const arr = [];

for (let i = 1; i <= N; i++) {
  arr.push(Number(input[i]));
}

const lis = [arr[0]];

for (let i = 1; i < N; i++) {
  if (arr[i] <= lis[0]) {
    lis[0] = arr[i];
  } else if (arr[i] > lis[lis.length - 1]) {
    lis.push(arr[i]);
  } else {
    let left = 0;
    let right = lis.length - 1;

    while (left + 1 < right) {
      let mid = Math.floor((left + right) / 2);

      if (arr[i] <= lis[mid]) {
        right = mid;
      } else {
        left = mid;
      }
    }

    lis[right] = arr[i];
  }
}

console.log(N - lis.length);
```

## 참고 자료

- <a href="https://namu.wiki/w/최장%20증가%20부분%20수열" target="_blank">최장 증가 부분 수열 - 나무위키</a>
